load("@stdlib//unittest", "unittest")
load("@vendor//asserts", "asserts")
load("@stdlib//hashlib", "hashlib")
load("@stdlib//binascii", "binascii")
load("@vgs//vault", "vault")
load("@vgs//http/request", "VGSHttpRequest")
load("@stdlib//builtins", builtins="builtins")
load("@stdlib//json", json="json")
load("@stdlib//json","json")
load("@vendor//jose/jwe", jwe="jwe")
load("@vendor//jose/jwk", jwk="jwk")
load("@vendor//jose/utils", base64url_encode="base64url_encode")
load("@vendor//jose/utils", base64url_decode="base64url_decode")
load("@vendor//jose/constants", ALGORITHMS="ALGORITHMS")
load("@stdlib//codecs", codecs="codecs")


def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
    signing_input = bytes([0x2e]).join([encoded_header, encoded_claims])
    k = jwk.construct(key, algorithm)
    signature = k.sign(signing_input)
    encoded_signature = base64url_encode(signature)
    encoded_string = bytes([0x2e]).join([encoded_header, encoded_claims, encoded_signature])
    return encoded_string.decode("utf-8")

def _encode_payload(payload):
    return base64url_encode(bytes(payload, 'utf-8'))

def _decode_payload(payload):
    return base64url_decode(bytes(payload, 'utf-8'))

def _encode_header(algorithm, additional_headers=None):
    header = {
        "typ": "JWT",
        "alg": algorithm
    }
    if additional_headers:
        header.update(additional_headers)
    json_header = json.dumps(header)
    return base64url_encode(bytes(json_header, 'utf-8'))

def sign(payload, key, headers=None, algorithm=ALGORITHMS.HS256):
    encoded_header = _encode_header(algorithm, additional_headers=headers)
    encoded_payload = _encode_payload(payload)
    signed_output = _sign_header_and_claims(encoded_header, encoded_payload, algorithm, key)
    return signed_output

def process(input, ctx):
    headers = input.headers
    body = json.loads(str(input.body))

    # keys below were generated by randomizer (they're not real):
    encryption_key = bytes('f09M3hEWUurTU2CKjBYGijbW3iAgK7hu', encoding='utf-8')
    signing_key = bytes('D33kJWq3nGYm1vosYyR0L65c2V6g5Zxq', encoding='utf-8')

    # encryption part:
    payload_json = json.dumps(body)
    encrypted_payload = jwe.encrypt(bytes(payload_json, encoding='utf-8'), encryption_key, algorithm='A256KW', encryption='A256GCM')

    # read timestamp from header
    ts = headers['Timestamp']
    headers.pop('Timestamp')
    iat = int(ts) // 1000
    exp = iat + 120
    custom_parameters = { 'iat': iat, 'exp': exp}
    signed_payload = sign(encrypted_payload, signing_key, headers=custom_parameters)

    # decryption part (opposite flow):
    encoded_string = codecs.encode(signed_payload, encoding='utf-8')
    encoded_header, encoded_claims, encoded_signature = encoded_string.split(bytes([0x2e]))
    decoded_payload = _decode_payload(encoded_claims)
    decrypted_payload = jwe.decrypt(decoded_payload, encryption_key)

    input.headers = headers
    input.body = decrypted_payload # since jwe.decrypt() returns bytes
    return input


def test_process():
    body = b'{"accountNumber":"4111111111111111","expirationMonth":"02","expirationYear":"2025","nameOnAccount":"John Doe","cardType":"DEBIT","cardBrand":"VISA"}'
    headers = {"Timestamp": "1647887942783"}
    input = VGSHttpRequest("https://VAULT_ID.sandbox.verygoodproxy.com/post", data=body, headers=headers, method='POST')
    response = process(input, None)
    expected_body = b'{"accountNumber":"4111111111111111","cardBrand":"VISA","cardType":"DEBIT","expirationMonth":"02","expirationYear":"2025","nameOnAccount":"John Doe"}'
    print(response.body)
    print(expected_body)
    asserts.assert_that(response.body).is_equal_to(expected_body)


def _testsuite():
  _suite = unittest.TestSuite()
  _suite.addTest(unittest.FunctionTestCase(test_process))
  return _suite

_runner = unittest.TextTestRunner()
_runner.run(_testsuite())