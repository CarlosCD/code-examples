data:
  - attributes:
      created_at: '2021-04-26T09:55:37'
      destination_override_endpoint: 'https://echo.apps.verygood.systems'
      entries:
        - classifiers: {}
          config:
            condition: AND
            rules:
              - condition: null
                expression:
                  field: PathInfo
                  operator: begins_with
                  type: string
                  values:
                    - /post
          id: 3e4ca047-23e2-4397-9a67-d673cedf4cc8
          id_selector: null
          operation: REDACT
          operations:
            - - name: github.com/verygoodsecurity/common/utils/date-time/Now
                parameters:
                  var: ctx.timestamp
              - name: github.com/verygoodsecurity/common/http/header/Set
                parameters:
                  header: Timestamp
                  value: ctx.timestamp
              - name: github.com/verygoodsecurity/common/compute/larky/http/Process
                parameters:
                  script: |-
                    load("@stdlib//json","json")
                    load("@stdlib//builtins", builtins="builtins")
                    load("@vendor//jose/jwe", jwe="jwe")
                    load("@vendor//jose/jwk", jwk="jwk")
                    load("@vendor//jose/utils", base64url_encode="base64url_encode")
                    load("@vendor//jose/utils", base64url_decode="base64url_decode")
                    load("@vendor//jose/constants", ALGORITHMS="ALGORITHMS")
                    load("@vgs//vault", "vault")
                    load("@stdlib//codecs", codecs="codecs")

                    def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
                        signing_input = bytes([0x2e]).join([encoded_header, encoded_claims])
                        k = jwk.construct(key, algorithm)
                        signature = k.sign(signing_input)
                        encoded_signature = base64url_encode(signature)
                        encoded_string = bytes([0x2e]).join([encoded_header, encoded_claims, encoded_signature])
                        return encoded_string.decode("utf-8")

                    def _encode_payload(payload):
                        return base64url_encode(bytes(payload, 'utf-8'))

                    def _decode_payload(payload):
                        return base64url_decode(bytes(payload, 'utf-8'))

                    def _encode_header(algorithm, additional_headers=None):
                        header = {
                            "typ": "JWT",
                            "alg": algorithm
                        }
                        if additional_headers:
                            header.update(additional_headers)
                        json_header = json.dumps(header)
                        return base64url_encode(bytes(json_header, 'utf-8'))

                    def sign(payload, key, headers=None, algorithm=ALGORITHMS.HS256):
                        encoded_header = _encode_header(algorithm, additional_headers=headers)
                        encoded_payload = _encode_payload(payload)
                        signed_output = _sign_header_and_claims(encoded_header, encoded_payload, algorithm, key)
                        return signed_output

                    def process(input, ctx):
                        headers = input.headers
                        body = json.loads(str(input.body))

                        # keys below were generated by randomizer (they're not real):
                        encryption_key = bytes('f09M3hEWUurTU2CKjBYGijbW3iAgK7hu', encoding='utf-8')
                        signing_key = bytes('D33kJWq3nGYm1vosYyR0L65c2V6g5Zxq', encoding='utf-8')

                        # encryption part:
                        payload_json = json.dumps(body)
                        encrypted_payload = jwe.encrypt(bytes(payload_json, encoding='utf-8'), encryption_key, algorithm='A256KW', encryption='A256GCM')

                        # read timestamp from header
                        ts = headers['Timestamp']
                        headers.pop('Timestamp')
                        iat = int(ts) // 1000
                        exp = iat + 120
                        custom_parameters = { 'iat': iat, 'exp': exp}
                        signed_payload = sign(encrypted_payload, signing_key, headers=custom_parameters)

                        # decryption part (opposite flow):
                        encoded_string = codecs.encode(signed_payload, encoding='utf-8')
                        encoded_header, encoded_claims, encoded_signature = encoded_string.split(bytes([0x2e]))
                        decoded_payload = _decode_payload(encoded_claims)
                        decrypted_payload = jwe.decrypt(decoded_payload, encryption_key)

                        input.headers = headers
                        input.body = decrypted_payload # since jwe.decrypt() returns bytes
                        return input
          phase: REQUEST
          public_token_generator: UUID
          targets:
            - body
          token_manager: PERSISTENT
          transformer: JSON_PATH
          transformer_config:
            - $.email
          transformer_config_map: null
      host_endpoint: (.*)\.verygoodproxy\.com
      id: c891d346-0e1b-49b8-99ac-0754d34f14f2
      ordinal: null
      port: 80
      protocol: http
      source_endpoint: '*'
      tags:
        name: echo.apps.verygood.systems-steel-blue-parallelogram
        source: RouteContainer
      updated_at: '2021-05-07T11:45:32'
    id: c891d346-0e1b-49b8-99ac-0754d34f14f2
    type: rule_chain
version: 1
